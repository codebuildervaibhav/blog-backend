# Database Overview

This document summarizes the database schema, relationships, and how to work with the database in this project.

Location of initial schema migration:

- `src/database/migrations/20251208094607_create_initial_schema.ts`

Database engine and extensions

- Database: PostgreSQL (assumed from use of `uuid-ossp`, `JSONB`, and `TEXT[]` types)
- Required extension: `uuid-ossp` (migration runs `CREATE EXTENSION IF NOT EXISTS "uuid-ossp";`)

High-level tables

- `users`
  - Primary key: `id` (UUID, generated by `uuidv7` in the application)
  - Columns: `email` (unique, not null), `display_name`, `avatar_url`, `bio`, `role` (enum: `admin`|`user`, default `user`), timestamps
  - Notes: `email` is unique and required.

- `local_auth`
  - Holds password hashes for local auth
  - Primary key & foreign key: `user_id` (UUID -> `users.id`) with `ON DELETE CASCADE`
  - Columns: `password_hash`, `security_stamp`

- `social_auth`
  - Social accounts linked to a `user`
  - Columns: `id` (UUID), `user_id` (UUID -> `users.id`, `ON DELETE CASCADE`), `provider`, `provider_account_id`, `tokens` (JSONB)
  - Unique constraint: `(provider, provider_account_id)`

- `posts`
  - Primary key: `id` (UUID)
  - Foreign key: `author_id` -> `users.id` with `ON DELETE CASCADE`
  - Columns: `title`, `slug` (unique), `content`, `is_published` (bool), `tags` (`TEXT[]`), `metadata` (JSONB, default `{}`), counters: `likes_count`, `comments_count`, `views_count`, timestamps
  - Notes: `tags` is stored as a Postgres text array; `metadata` is free-form JSON for misc properties.

- `trending_posts`
  - Primary key: `id` (UUID)
  - Foreign key: `post_id` -> `posts.id` with `ON DELETE CASCADE`
  - Columns: `trend_score` (float), `rank` (int), `calculated_at` (timestamp, default now)
  - Notes: Intended to store precomputed ranking info for fast reads.

- `comments`
  - Primary key: `id` (UUID)
  - Foreign keys: `post_id` -> `posts.id` (`ON DELETE CASCADE`), `user_id` -> `users.id` (`ON DELETE SET NULL`)
  - Supports threaded comments via `parent_id` -> `comments.id`
  - Columns: `content`, timestamps

- `post_likes`
  - Join table for who liked which post
  - Composite primary key: (`user_id`, `post_id`)
  - Foreign keys: `user_id` -> `users.id` (`ON DELETE CASCADE`), `post_id` -> `posts.id` (`ON DELETE CASCADE`)
  - Columns: `created_at` (timestamp)

Constraints and referential behavior

- Many foreign keys use `ON DELETE CASCADE` so child rows are removed when a parent is removed (e.g., deleting a `user` removes local_auth, social_auth, posts, post_likes).
- `comments.user_id` uses `ON DELETE SET NULL` so comments persist when a user is deleted but the author link becomes NULL.
- Unique indexes: `users.email`, `social_auth(provider, provider_account_id)`, `posts.slug`.

Important data types

- UUID primary keys are now generated in the application using the `uuidv7` library. This provides chronological ordering, which is beneficial for performance and debugging.
- `JSONB` used for `social_auth.tokens` and `posts.metadata`.
- `TEXT[]` used for `posts.tags`.
- Enum for `users.role` with values `admin` and `user`.

Running and managing migrations

- Migrations are managed with Knex. The repository includes `knexfile.ts`.
- Typical commands (run from project root):

```powershell
npx knex migrate:latest
npx knex migrate:rollback
npx knex migrate:status
```

(You may need to set `NODE_ENV` or ensure your environment variables for DB connection are available. Check `knexfile.ts` for configuration details.)

Common queries / example Knex snippets

- Create a user (and return the new row)

```ts
// In your service
import { uuidv7 } from 'uuidv7';

const newId = uuidv7(); // "018b..."

// knex is an instance of Knex
const [user] = await knex('users')
  .insert({
    id: newId,
    email: 'alice@example.com',
    display_name: 'Alice',
  })
  .returning('*');
```

- Get a published post by slug with author and comment count

```ts
const post = await knex('posts as p')
  .select('p.*', 'u.display_name as author_name')
  .leftJoin('users as u', 'p.author_id', 'u.id')
  .where({ 'p.slug': slug, 'p.is_published': true })
  .first();

const comments = await knex('comments')
  .where({ post_id: post.id })
  .orderBy('created_at');
```

- Increment view counter (atomic)

```ts
await knex('posts').where({ id: postId }).increment('views_count', 1);
```

- Like a post (insert into `post_likes`), and increment `likes_count` in `posts` inside a transaction

```ts
await knex.transaction(async (trx) => {
  await trx('post_likes').insert({ user_id: userId, post_id: postId });
  await trx('posts').where({ id: postId }).increment('likes_count', 1);
});
```

- Add a comment and increment `comments_count`

```ts
await knex.transaction(async (trx) => {
  const [comment] = await trx('comments')
    .insert({ post_id: postId, user_id: userId, content })
    .returning('*');
  await trx('posts').where({ id: postId }).increment('comments_count', 1);
  return comment;
});
```

Notes and recommendations

- Keep counter columns (`likes_count`, `comments_count`, `views_count`) eventually consistent if you plan heavy concurrent writes; you can compute counters with materialized views or periodic aggregation if accuracy is critical.
- Consider adding indexes on `posts(is_published)`, `posts(author_id)`, and `comments(post_id)` for read-heavy workloads.
- `TEXT[]` operations are fine in Postgres but if you want flexible tag search consider a `post_tags` join table for normalized querying and indexing.
- Carefully handle `JSONB` searches with GIN indexes when you need to query within `metadata` or `tokens`.

Where to look next in the repository

- `src/database/migrations/20251208094607_create_initial_schema.ts` — migration file used as source of truth for this doc
- `knexfile.ts` — DB connection configuration

Next steps (suggested)

- Implement TypeScript repository (data access) layer using Knex or an ORM.
- Add tests for migrations and common queries.
- Decide indexing strategy and add indexes in a follow-up migration.

If you'd like, I can:

- Generate a set of TypeScript data-access functions (e.g., `users.repo.ts`, `posts.repo.ts`).
- Add recommended indexes in a new migration.
- Create sample seed data and seed scripts.
